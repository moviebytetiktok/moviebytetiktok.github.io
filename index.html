<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Subtitle Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen">
  <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-2xl">
    <h1 class="text-2xl font-bold mb-4 text-center">Video Subtitle Generator</h1>
    <input type="file" id="videoInput" accept="video/*" class="mb-4 w-full p-2 border rounded">
    <video id="videoPlayer" controls class="w-full mb-4" style="display: none;"></video>
    <canvas id="canvas" style="display: none;"></canvas>
    <button id="processButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600 mb-2" disabled>Process Video</button>
    <button id="downloadButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600" style="display: none;">Download Video with Subtitles</button>
    <p id="status" class="mt-4 text-center"></p>
  </div>

  <script>
    const videoInput = document.getElementById('videoInput');
    const videoPlayer = document.getElementById('videoPlayer');
    const canvas = document.getElementById('canvas');
    const processButton = document.getElementById('processButton');
    const downloadButton = document.getElementById('downloadButton');
    const status = document.getElementById('status');
    const ctx = canvas.getContext('2d');

    let recognition;
    let subtitles = [];
    let isProcessing = false;
    let mediaRecorder;
    let recordedChunks = [];

    // Check if Web Speech API and MediaRecorder are available
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      status.textContent = 'Web Speech API not supported. Using test subtitles.';
      console.warn('Web Speech API unavailable. Using dummy subtitles for testing.');
    } else {
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
    }

    if (!window.MediaRecorder) {
      status.textContent = 'MediaRecorder API is not supported in this browser.';
      processButton.disabled = true;
    }

    // Enable process button when video is selected
    videoInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        videoPlayer.src = url;
        videoPlayer.style.display = 'block';
        processButton.disabled = false;
        status.textContent = 'Video loaded. Click "Process Video" to generate subtitles.';
        videoPlayer.onloadedmetadata = () => {
          canvas.width = videoPlayer.videoWidth;
          canvas.height = videoPlayer.videoHeight;
          console.log('Canvas set to:', canvas.width, 'x', canvas.height);
        };
      }
    });

    // Process video for subtitles and record with subtitles
    processButton.addEventListener('click', async () => {
      if (isProcessing) return;
      isProcessing = true;
      processButton.disabled = true;
      downloadButton.style.display = 'none';
      recordedChunks = [];
      status.textContent = 'Processing audio and rendering subtitles...';

      subtitles = [];
      const track = videoPlayer.textTracks[0] || videoPlayer.addTextTrack('subtitles', 'English', 'en');
      track.mode = 'showing';

      // Combine video canvas stream with audio stream
      const videoStream = canvas.captureStream(30);
      const audioStream = videoPlayer.captureStream ? videoPlayer.captureStream() : videoPlayer.mozCaptureStream ? videoPlayer.mozCaptureStream() : null;
      let combinedStream = videoStream;
      if (audioStream && audioStream.getAudioTracks().length > 0) {
        combinedStream = new MediaStream([...videoStream.getVideoTracks(), ...audioStream.getAudioTracks()]);
        console.log('Audio tracks included:', audioStream.getAudioTracks());
      } else {
        console.warn('No audio stream available.');
      }

      try {
        mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm;codecs=vp8,opus' });
      } catch (e) {
        status.textContent = 'MediaRecorder initialization failed: ' + e.message;
        isProcessing = false;
        processButton.disabled = false;
        return;
      }

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
          console.log('Recorded chunk size:', event.data.size);
        }
      };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        downloadButton.style.display = 'block';
        downloadButton.onclick = () => {
          const a = document.createElement('a');
          a.href = url;
          a.download = 'video_with_subtitles.webm';
          a.click();
          URL.revokeObjectURL(url);
        };
        status.textContent = 'Video recorded. Click "Download Video with Subtitles" to save.';
      };
      mediaRecorder.onerror = (event) => {
        status.textContent = `MediaRecorder error: ${event.error}`;
        isProcessing = false;
        processButton.disabled = false;
      };

      // Render video and subtitles on canvas
      function renderFrame() {
        if (!isProcessing) return;
        ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
        const currentTime = videoPlayer.currentTime;
        const activeSubtitle = subtitles.find(sub => currentTime >= sub.start && currentTime <= sub.end);
        if (activeSubtitle) {
          ctx.font = 'bold 32px Arial';
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 4;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          const text = activeSubtitle.text;
          const textWidth = ctx.measureText(text).width;
          const padding = 15;
          const boxHeight = 50;
          const boxY = canvas.height - boxHeight - 20;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect((canvas.width - textWidth - padding * 2) / 2, boxY, textWidth + padding * 2, boxHeight);
          ctx.fillStyle = 'white';
          ctx.strokeText(text, canvas.width / 2, canvas.height - 25);
          ctx.fillText(text, canvas.width / 2, canvas.height - 25);
          console.log('Rendering subtitle:', text, 'at time:', currentTime);
        }
        requestAnimationFrame(renderFrame);
      }

      // Fallback: Generate dummy subtitles if no speech recognition
      function generateDummySubtitles(duration) {
        const interval = 5; // 5-second intervals
        for (let i = 0; i < duration; i += interval) {
          const subtitleText = `Test subtitle at ${i}s`;
          subtitles.push({ start: i, end: i + interval, text: subtitleText });
          addSubtitleToTrack(track, i, i + interval, subtitleText);
          console.log('Added dummy subtitle:', subtitleText, 'from', i, 'to', i + interval);
        }
      }

      if (recognition) {
        recognition.onresult = (event) => {
          let interimTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              const startTime = videoPlayer.currentTime;
              const endTime = startTime + 2;
              subtitles.push({ start: startTime, end: endTime, text: transcript });
              addSubtitleToTrack(track, startTime, endTime, transcript);
              console.log('Subtitle added:', transcript, 'from', startTime, 'to', endTime);
            } else {
              interimTranscript += transcript;
            }
          }
        };

        recognition.onerror = (event) => {
          status.textContent = `Speech recognition error: ${event.error}. Using test subtitles.`;
          console.warn('Speech recognition failed. Generating dummy subtitles.');
          generateDummySubtitles(videoPlayer.duration || 60);
        };

        recognition.onend = () => {
          if (isProcessing) {
            recognition.start();
          }
        };
      } else {
        generateDummySubtitles(videoPlayer.duration || 60);
      }

      try {
        videoPlayer.play();
        if (recognition) recognition.start();
        mediaRecorder.start();
        renderFrame();
        console.log('Started recording with MediaRecorder');

        videoPlayer.onended = () => {
          if (recognition) recognition.stop();
          mediaRecorder.stop();
          isProcessing = false;
          processButton.disabled = false;
          generateVTTFile();
          if (subtitles.length === 0) {
            status.textContent = 'No subtitles generated. Check audio or try a different video.';
          }
        };
      } catch (error) {
        status.textContent = `Error: ${error.message}`;
        isProcessing = false;
        processButton.disabled = false;
        mediaRecorder.stop();
      }
    });

    // Add subtitle to text track
    function addSubtitleToTrack(track, start, end, text) {
      track.addCue(new VTTCue(start, end, text));
    }

    // Generate and apply VTT file for video player
    function generateVTTFile() {
      let vttContent = 'WEBVTT\n\n';
      subtitles.forEach(sub => {
        const start = formatTime(sub.start);
        const end = formatTime(sub.end);
        vttContent += `${start} --> ${end}\n${sub.text}\n\n`;
      });

      const blob = new Blob([vttContent], { type: 'text/vtt' });
      const url = URL.createObjectURL(blob);
      const existingTrack = videoPlayer.querySelector('track');
      if (existingTrack) {
        existingTrack.src = url;
      } else {
        const trackElement = document.createElement('track');
        trackElement.kind = 'subtitles';
        trackElement.label = 'English';
        trackElement.srclang = 'en';
        trackElement.src = url;
        trackElement.default = true;
        videoPlayer.appendChild(trackElement);
      }
    }

    // Format time for VTT (e.g., 00:00:00.000)
    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      const millis = Math.floor((seconds % 1) * 1000);
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
    }
  </script>
</body>
</html>
