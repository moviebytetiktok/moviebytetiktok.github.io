<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Subtitle Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen">
  <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-2xl">
    <h1 class="text-2xl font-bold mb-4 text-center">Video Subtitle Generator</h1>
    <input type="file" id="videoInput" accept="video/*" class="mb-4 w-full p-2 border rounded">
    <video id="videoPlayer" controls class="w-full mb-4" style="display: none;"></video>
    <canvas id="canvas" style="display: none;"></canvas>
    <button id="processButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600 mb-2" disabled>Process Video</button>
    <button id="downloadButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600" style="display: none;">Download Video with Subtitles</button>
    <p id="status" class="mt-4 text-center"></p>
  </div>

  <script>
    const videoInput = document.getElementById('videoInput');
    const videoPlayer = document.getElementById('videoPlayer');
    const canvas = document.getElementById('canvas');
    const processButton = document.getElementById('processButton');
    const downloadButton = document.getElementById('downloadButton');
    const status = document.getElementById('status');
    const ctx = canvas.getContext('2d');

    let recognition;
    let subtitles = [];
    let isProcessing = false;
    let mediaRecorder;
    let recordedChunks = [];

    // Check if Web Speech API and MediaRecorder are available
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const MediaRecorder = window.MediaRecorder;
    if (!SpeechRecognition) {
      status.textContent = 'Web Speech API is not supported in this browser.';
      processButton.disabled = true;
    } else {
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
    }

    // Enable process button when video is selected
    videoInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        videoPlayer.src = url;
        videoPlayer.style.display = 'block';
        processButton.disabled = false;
        status.textContent = 'Video loaded. Click "Process Video" to generate subtitles.';
        // Set canvas dimensions to match video
        videoPlayer.onloadedmetadata = () => {
          canvas.width = videoPlayer.videoWidth;
          canvas.height = videoPlayer.videoHeight;
        };
      }
    });

    // Process video for subtitles and record with subtitles
    processButton.addEventListener('click', async () => {
      if (isProcessing) return;
      isProcessing = true;
      processButton.disabled = true;
      downloadButton.style.display = 'none';
      recordedChunks = [];
      status.textContent = 'Processing audio and rendering subtitles...';

      subtitles = [];
      const track = videoPlayer.textTracks[0] || videoPlayer.addTextTrack('subtitles', 'English', 'en');
      track.mode = 'showing';

      // Set up MediaRecorder to capture canvas
      const stream = canvas.captureStream(30); // 30 fps
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        downloadButton.style.display = 'block';
        downloadButton.onclick = () => {
          const a = document.createElement('a');
          a.href = url;
          a.download = 'video_with_subtitles.webm';
          a.click();
          URL.revokeObjectURL(url);
        };
        status.textContent = 'Subtitles generated and video recorded. Click "Download Video with Subtitles" to save.';
      };

      // Render video and subtitles on canvas
      function renderFrame() {
        if (!isProcessing) return;
        ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
        const currentTime = videoPlayer.currentTime;
        const activeSubtitle = subtitles.find(sub => currentTime >= sub.start && currentTime <= sub.end);
        if (activeSubtitle) {
          ctx.font = '24px Arial';
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.strokeText(activeSubtitle.text, canvas.width / 2, canvas.height - 20);
          ctx.fillText(activeSubtitle.text, canvas.width / 2, canvas.height - 20);
        }
        requestAnimationFrame(renderFrame);
      }

      recognition.onresult = (event) => {
        let interimTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            const startTime = videoPlayer.currentTime;
            const endTime = startTime + 2; // Approximate duration for each subtitle
            subtitles.push({ start: startTime, end: endTime, text: transcript });
            addSubtitleToTrack(track, startTime, endTime, transcript);
          } else {
            interimTranscript += transcript;
          }
        }
      };

      recognition.onerror = (event) => {
        status.textContent = `Error in speech recognition: ${event.error}`;
        isProcessing = false;
        processButton.disabled = false;
        mediaRecorder.stop();
      };

      recognition.onend = () => {
        if (isProcessing) {
          recognition.start(); // Restart recognition if still processing
        }
      };

      try {
        videoPlayer.play();
        recognition.start();
        mediaRecorder.start();
        renderFrame();

        videoPlayer.onended = () => {
          recognition.stop();
          mediaRecorder.stop();
          isProcessing = false;
          processButton.disabled = false;
          generateVTTFile();
        };
      } catch (error) {
        status.textContent = `Error: ${error.message}`;
        isProcessing = false;
        processButton.disabled = false;
        mediaRecorder.stop();
      }
    });

    // Add subtitle to text track
    function addSubtitleToTrack(track, start, end, text) {
      track.addCue(new VTTCue(start, end, text));
    }

    // Generate and apply VTT file for video player
    function generateVTTFile() {
      let vttContent = 'WEBVTT\n\n';
      subtitles.forEach(sub => {
        const start = formatTime(sub.start);
        const end = formatTime(sub.end);
        vttContent += `${start} --> ${end}\n${sub.text}\n\n`;
      });

      const blob = new Blob([vttContent], { type: 'text/vtt' });
      const url = URL.createObjectURL(blob);
      const existingTrack = videoPlayer.querySelector('track');
      if (existingTrack) {
        existingTrack.src = url;
      } else {
        const trackElement = document.createElement('track');
        trackElement.kind = 'subtitles';
        trackElement.label = 'English';
        trackElement.srclang = 'en';
        trackElement.src = url;
        trackElement.default = true;
        videoPlayer.appendChild(trackElement);
      }
    }

    // Format time for VTT (e.g., 00:00:00.000)
    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      const millis = Math.floor((seconds % 1) * 1000);
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
    }
  </script>
</body>
</html>
